#!/usr/bin/runhaskell
import Distribution.Franchise
import Data.List ( sort, isSuffixOf, isPrefixOf )

configure = do copyright "David Roundy"
               license "BSD3"
               addExtraData "category" "Distribution"
               addExtraData "synopsis"
                   "A package for configuring and building Haskell software"
               addExtraData "description" $ unlines
                   ["",
                    "        Franchise is an easy-to use package for building Haskell",
                    "        software.  Unlike Cabal, you aren't required to track every",
                    "        possible dependency in every possible build condition.  In",
                    "        addition, you are not required to use an external tool such as",
                    "        autoconf in order to configure the build based on which",
                    "        packages, libraries and tools are present.",
                    "",
                    "        Note: the cabal dependencies are autogenerated, and approximate."]
               ghcFlags ["-threaded","-O2","-Wall"]

main = build [] configure $ do -- versionFromDarcs doesn't go in configure
                               -- because we want to rerun it with each
                               -- build rather than waiting for the user to
                               -- run Setup.hs configure again.
                               versionFromDarcs
                               buildDoc
                               darcsDist "franchise" ["franchise.cabal"]
                               package "franchise" ["Distribution.Franchise"] []

buildDoc = do rm_rf "doc/tests"
              addTarget $ ["*webpage*"] :< ["*manual*","index.html"] |<- defaultRule
              addTarget $ ["index.html"] :< ["doc/home.txt"] |<- defaultRule { make = makeroot }
              alltests <- mapDirectory buildOneDoc "doc"
              here <- pwd
              let prepareForTest = -- make a local install of franchise for test
                      do setEnv "HOME" (here++"/doc/tests")
                         mkdir "dop/tests/lib"
                         mv "franchise.config" "franchise.config.correct"
                         mapM_ cleanTarget ["franchise.config"]
                         addExtraData "libdir" (here++"/doc/tests/lib")
                         pkgFlags ["--user"]
                         clearInstallTarget
                         package "franchise" ["Distribution.Franchise"] []
                         buildTarget "*install*"
                         mv "franchise.config.correct" "franchise.config"
              test prepareForTest $ concatMap snd alltests
              withDirectory "doc" $ do buildIndex (concatMap fst alltests)
                                       htmls <- concat `fmap` mapM buildHtml (concatMap fst alltests)
                                       addTarget $ ["*manual*","*html*"] :<
                                                     ("manual/index.html":htmls) |<- defaultRule
    where buildOneDoc f | not (".txt.in" `isSuffixOf` f) = return ([],[])
          buildOneDoc f = do tests0@(txtf:_) <- splitFile f (\x -> ("manual/"++take (length f-3) f,
                                                                    unlines (concatMap purge $ lines x))
                                                             : splitf (lines x))
                             let tests = map splitPath $
                                         filter (".sh" `isSuffixOf`) $
                                         filter ("tests/" `isPrefixOf`) tests0
                             ts <- mapM (\ (d, t) -> withDirectory d $ testOne "bash" t) tests
                             return ([txtf],ts)
          buildHtml f = withProgram "markdown" [] $ \markdown ->
                        do withd <- rememberDirectory
                           x <- cat f
                           let makehtml = withd $ do putS $ "["++markdown++"] doc/manual/"++f
                                                     html <- systemOut markdown [f]
                                                     mkFile htmlname $
                                                            unlines [htmlHead "../doc.css" x,html,htmlTail]
                               htmlname = take (length f - 4) f++".html"
                           addTarget $ [htmlname] :< [f]
                               |<- defaultRule { make = const makehtml }
                           return [htmlname]
          buildIndex inps =
              withProgram "markdown" [] $ \markdown ->
                  do withd <- rememberDirectory
                     let mklink mkdnf = do title <- (head . filter (not . null) . lines) `fmap` cat mkdnf
                                           return $ '[':title++"]("++
                                                  drop 7 (take (length mkdnf-4) mkdnf)++".html)\n"
                         makeindex _ = withd $
                                       do putS $ "["++markdown++"] doc/manual.txt"
                                          indhead <- cat "manual.txt"
                                          links <- mapM mklink $ sort inps
                                          html <- systemInOut markdown [] $
                                                  indhead ++ "\n\n"++unlines links
                                          mkFile "manual/index.html" $
                                                 unlines [htmlHead "../doc.css" indhead,html,htmlTail]
                     addTarget $ ["manual/index.html"] :< ("manual.txt":inps)
                         |<- defaultRule { make = makeindex }
          makeroot _ = withProgram "markdown" [] $ \markdown ->
                       do putS $ "["++markdown++"] doc/home.txt"
                          html <- systemOut markdown ["doc/home.txt"]
                          mkFile "index.html" $
                                 unlines [htmlHead "doc/doc.css" "Franchise",html,htmlTail]
          purge l | "...." `isPrefixOf` l = []
                  | otherwise = case stripPrefix "file: " l of
                                Just fn -> ['*':fn++":*",""] -- need blank line to get code mode
                                Nothing -> [l]
          splitf (x:r) =
              case stripPrefix "file: " x of
              Nothing -> splitf r
              Just fn -> case break (\l -> not $ "    " `isPrefixOf` l || "...." `isPrefixOf` l) r of
                         (fc, rest) ->
                             (fn, unlines $ map (drop 4) fc) : splitf rest
          splitf [] = []
          splitOn x (c:cs) = case stripPrefix x (c:cs) of
                             Just cs' -> Just ([],cs')
                             Nothing -> do (cs1,cs2) <- splitOn x cs
                                           Just (c:cs1,cs2)
          splitOn _ [] = Nothing
          stripPrefix [] ys = Just ys
          stripPrefix (x:xs) (y:ys) | x == y = stripPrefix xs ys
          stripPrefix _ _ = Nothing

htmlHead css x = unlines ["<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"",
                          " \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n",
                          "<html xml:lang=\"en-US\" lang=\"en-US\">",
                          "<head>",
                          unwords ["<title>",head $ filter (not . null) $ lines x,"</title>"],
                          "<link rel=\"stylesheet\" type=\"text/css\" href=\""++css++"\" />",
                          "</head>",
                          "<body>"]

htmlTail = unlines ["</body>",
                    "</html>"]
