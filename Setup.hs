#!/usr/bin/runhaskell
import Distribution.Franchise
import Data.List ( isSuffixOf, isPrefixOf )

configure = do copyright "David Roundy"
               license "BSD3"
               addExtraData "category" "Distribution"
               addExtraData "synopsis"
                   "A package for configuring and building Haskell software"
               addExtraData "description" $ unlines
                   ["",
                    "        Franchise is an easy-to use package for building Haskell",
                    "        software.  Unlike Cabal, you aren't required to track every",
                    "        possible dependency in every possible build condition.  In",
                    "        addition, you are not required to use an external tool such as",
                    "        autoconf in order to configure the build based on which",
                    "        packages, libraries and tools are present.",
                    "",
                    "        Note: the cabal dependencies are autogenerated, and approximate."]
               ghcFlags ["-threaded","-O2","-Wall"]

main = build [] configure $ do -- versionFromDarcs doesn't go in configure
                               -- because we want to rerun it with each
                               -- build rather than waiting for the user to
                               -- run Setup.hs configure again.
                               versionFromDarcs
                               buildDoc
                               darcsDist "franchise" ["franchise.cabal"]
                               package "franchise" ["Distribution.Franchise"] []

buildDoc = do alltests <- mapDirectory buildOneDoc "doc"
              test $ concat alltests
              withDirectory "doc" $ do txts <- filter (".text" `isSuffixOf`) `fmap` ls "."
                                       htmls <- concat `fmap` mapM buildHtml txts
                                       addTarget $ ["*manual*","*html*"] :< htmls |<- defaultRule
    where buildOneDoc f | not (".in" `isSuffixOf` f) = return []
          buildOneDoc f = do tests0 <- splitFile f (\x -> (take (length f-3) f,
                                                           unlines (concatMap purge $ lines x))
                                                          : splitf (lines x))
                             let tests = map splitPath $
                                         filter (".sh" `isSuffixOf`) $
                                         filter ("tests/" `isPrefixOf`) tests0
                             mapM (\ (d, t) -> withDirectory d $ testOne "bash" t) tests
          buildHtml f = withProgram "markdown" [] $ \markdown ->
                        do withd <- rememberDirectory
                           let makehtml = withd $
                                do mkdir "manual"
                                   systemOut markdown [f] >>= writeF htmlname
                               htmlname = "manual/"++ take (length f - 5) f++".html"
                           addTarget $ [htmlname] :< [f]
                               |<- defaultRule { make = const makehtml }
                           return [htmlname]
          purge l | "...." `isPrefixOf` l = []
                  | otherwise = case stripPrefix "file: " l of
                                Just fn -> ['*':fn++":*",""] -- need blank line to get code mode
                                Nothing -> [l]
          splitf (x:r) =
              case stripPrefix "file: " x of
              Nothing -> splitf r
              Just fn -> case break (\l -> not $ "    " `isPrefixOf` l || "...." `isPrefixOf` l) r of
                         (fc, rest) ->
                             (fn, unlines $ filter ("    " `isPrefixOf`) fc) : splitf rest
          splitf [] = []
          splitOn x (c:cs) = case stripPrefix x (c:cs) of
                             Just cs' -> Just ([],cs')
                             Nothing -> do (cs1,cs2) <- splitOn x cs
                                           Just (c:cs1,cs2)
          splitOn _ [] = Nothing
          stripPrefix [] ys = Just ys
          stripPrefix (x:xs) (y:ys) | x == y = stripPrefix xs ys
          stripPrefix _ _ = Nothing
