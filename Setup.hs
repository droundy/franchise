#!/usr/bin/runhaskell
import Distribution.Franchise
import Data.List ( isSuffixOf, isPrefixOf )

configure = do copyright "David Roundy"
               license "BSD3"
               addExtraData "category" "Distribution"
               addExtraData "synopsis"
                   "A package for configuring and building Haskell software"
               addExtraData "description" $ unlines
                   ["",
                    "        Franchise is an easy-to use package for building Haskell",
                    "        software.  Unlike Cabal, you aren't required to track every",
                    "        possible dependency in every possible build condition.  In",
                    "        addition, you are not required to use an external tool such as",
                    "        autoconf in order to configure the build based on which",
                    "        packages, libraries and tools are present.",
                    "",
                    "        Note: the cabal dependencies are autogenerated, and approximate."]
               ghcFlags ["-threaded","-O2","-Wall"]

main = build [] configure $ do -- versionFromDarcs doesn't go in configure
                               -- because we want to rerun it with each
                               -- build rather than waiting for the user to
                               -- run Setup.hs configure again.
                               versionFromDarcs
                               buildDoc
                               darcsDist "franchise" ["franchise.cabal"]
                               package "franchise" ["Distribution.Franchise"] []

buildDoc = do alltests <- mapDirectory buildOneDoc "doc"
              test $ concat alltests
              withDirectory "doc" $ do rsts <- filter (".rst" `isSuffixOf`) `fmap` ls "."
                                       htmls <- concat `fmap` mapM buildHtml rsts
                                       addTarget $ ["*manual*"] :< htmls |<- defaultRule
    where buildOneDoc f | not (".in" `isSuffixOf` f) = return []
          buildOneDoc f = do tests0 <- splitFile f (\x -> purge f "" x++splitf f x)
                             let tests = map splitPath $
                                         filter (".sh" `isSuffixOf`) $
                                         filter ("tests/" `isPrefixOf`) tests0
                             mapM (\ (d, t) -> withDirectory d $ testOne "bash" t) tests
          buildHtml f = withProgram "rst2html" [] $ \rst2html ->
                        do withd <- rememberDirectory
                           let makehtml = withd $
                                do mkdir "manual"
                                   system "rst2html" [f,htmlname]
                               htmlname = "manual/"++ take (length f - 4) f++".html"
                           addTarget $ [htmlname] :< [f]
                               |<- defaultRule { make = const makehtml }
                           return [htmlname]
          purge f _ _ | not (".in" `isSuffixOf` f) = []
          purge f sofar x =
              case splitOn "\\begin{file}{" x of
              Nothing -> [(reverse $ drop 3 $ reverse f, sofar++x)]
              Just (before,after) ->
                  case splitOn "}\n" after of
                  Nothing -> [(reverse $ drop 3 $ reverse f, sofar++before)]
                  Just (fn,after2) ->
                      case splitOn "\\end{file}" after2 of
                      Nothing -> [(reverse $ drop 3 $ reverse f, sofar++before)]
                      Just (contents,after3) ->
                          purge f (sofar++before++"`file: "++fn++"`::\n\n"++
                                   unlines (map ("    "++) $ lines contents)) after3
          splitf f x = case splitOn "\\begin{file}{" x of
                       Nothing -> []
                       Just (_,after) ->
                         case splitOn "}\n" after of
                         Nothing -> [(f++".error", "Parse failure on:\n"++after)]
                         Just (fn,after2) ->
                           case splitOn "\\end{file}" after2 of
                           Nothing -> [(f++".error", "Parse failure on:\n"++after2)]
                           Just (contents,after3) -> (fn,contents): splitf f after3
          splitOn x (c:cs) = case stripPrefix x (c:cs) of
                             Just cs' -> Just ("",cs')
                             Nothing -> do (cs1,cs2) <- splitOn x cs
                                           Just (c:cs1,cs2)
          splitOn _ "" = Nothing
          stripPrefix [] ys = Just ys
          stripPrefix (x:xs) (y:ys) | x == y = stripPrefix xs ys
          stripPrefix _ _ = Nothing
